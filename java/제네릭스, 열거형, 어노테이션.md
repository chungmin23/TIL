# 제네릭스, 열거형, 어노테이션

## 제네릭스

- 컴파일시 타입을 체크해주는 기능 
- 타입이 일치안하면 컴파일에러 발생

### 타입변수

- 객체생성시 타입변수 (E) 대신 실제타입을 지정 

### 지네릭 타입과 다형성

- 참조변수에 지정해준 지네릭 타입과 생성자에 지정해준 지네릭 타입은 일치해야 한다 

~~~java
ArrayList<Tv> list = new ArrayList<Tv>(); // ok 일치
ArrayList<Product> list = new ArrayList<Tv>(); // 에러
~~~

- 클래스의 타입간에 다형성은 적용가능

~~~java
List<Tv> list = new ArrayList<Tv>(); //OK
List<Tv> list = new LinkedList<Tv>(); //OK
~~~

- 매개변수의 다형성도 성립



### 제한된 지네릭 클래스

- extends로 대입할수 있는 타입을 제한

~~~java
//Fruit 자손만 대입 가능 	
class FruitBox<T extends Fruit> {

}

//인터페이스 인 경우도 extends 사용
interface Eatable {}
class FruitBox<T extends Eatable> {...}
~~~



### 지네릭스의 제약

1. static멤버에 타입 변수 사용불가 

   - 타입 변수에 대입은 인스턴스 별로 다르게 가능하기 때문에 

2. 배열 생성할때 타입변수 사용불가 , 단 배열 선언할때는 가능

   ~~~java
   T[] item; // 가능
   T[] tmpArr = new T[itemArr.length]; 불가
   ~~~

   - new 연산자 생성시 타입이 확정이 되어야 하기 때문에 

   

### 와일드 카드 <?>

|     명칭      |                        설명                        |
| :-----------: | :------------------------------------------------: |
| <? extends T> |    와일드 카드의 상한제한, T와 그 자손들만 가능    |
|  <? super T>  |   와일드 카드의 하한 제한. T와 그 조상들만 가능    |
|      <?>      | 제한없음 모든 타입 가능, <? extends Object>와 동일 |

- 메서드 매개변수에도 와일드카드 사용가능



### 제네릭 메서드

- 메서드 호출할 때마다 다른 제네릭스 타입 지정가능.



### 지네릭 형변환

-  지네릭 타입의 형변환 : 지네릭타입과 원시 타입간의 형변환은 바람직 하지 않다.(경고 발생), 원시타입 사용하는 것 자체가 별로인 것  
-  지네릭 타입 -> 원시타입(경고 발생), 원시 타입 -> 지네릭 타입(경고 발생)
-   Box<String> -> Box<Object> or Box<String> -> Box<Object> 는 형변환 안됨(에러)



### 지네릭 타입 제거

지네릭 타입의 제거 : 하위호환성과, 안정성 문제 때문에 자바 컴파일러는 지네릭 타입을 제거하고 필요한 곳에 형변환을 넣는다 

1) 지네릭 타입의 경계(bound)를 제거(T -> Object or 제한된 타입) 
2) 지네릭 타입 제거 후에 타입이 불일치 하면 형변환을 추가 
3) 와일드 카드가 포함된 경우엔, 적절한 타입으로 형변환 추가